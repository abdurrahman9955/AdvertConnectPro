{"version":3,"file":"useExternalRef.js","names":["useExternalRef","externalRef","refCopy","useRef","refSetter","useCallback","value","setRefsValue","refs","ref","setRefValue","current"],"sources":["../source/useExternalRef.js"],"sourcesContent":["import { useRef, useCallback } from 'react'\r\n\r\n/**\r\n * This hook creates an internal copy of a `ref`\r\n * and returns a new `ref`-alike setter function\r\n * that updates both `ref` and the internal copy of it.\r\n * That `ref`-alike setter function could then be passed\r\n * to child elements instead of the original `ref`.\r\n *\r\n * The internal copy of the `ref` can then be used to\r\n * call instance methods like `.focus()`, etc.\r\n *\r\n * One may ask: why create a copy of `ref` for \"internal\" use\r\n * when the code could use the original `ref` for that.\r\n * The answer is: the code would have to dance around the original `ref` anyway\r\n * to figure out whether it exists and to find out the internal implementation of it\r\n * in order to read its value correctly. This hook encapsulates all that \"boilerplate\" code.\r\n * The returned copy of the `ref` is guaranteed to exist and functions as a proper ref \"object\".\r\n * The returned `ref`-alike setter function must be used instead of the original `ref`\r\n * when passing it to child elements.\r\n *\r\n * @param  {(object|function)} [externalRef] â€” The original `ref` that may have any internal implementation and might not even exist.\r\n * @return {any[]} Returns an array of two elements: a copy of the `ref` for \"internal\" use and a `ref`-alike setter function that should be used in-place of the original `ref` when passing it to child elements.\r\n */\r\nexport default function useExternalRef(externalRef) {\r\n  // Create a copy of the original `ref` (which might not exist).\r\n  // Both refs will point to the same value.\r\n  const refCopy = useRef()\r\n\r\n  // Updates both `ref`s with the same `value`.\r\n  const refSetter = useCallback((value) => {\r\n    setRefsValue([externalRef, refCopy], value)\r\n  }, [\r\n    externalRef,\r\n    refCopy\r\n  ])\r\n\r\n  return [refCopy, refSetter]\r\n}\r\n\r\n// Sets the same `value` of all `ref`s.\r\n// Some of the `ref`s may not exist in which case they'll be skipped.\r\nexport function setRefsValue(refs, value) {\r\n  for (const ref of refs) {\r\n    if (ref) {\r\n      setRefValue(ref, value)\r\n    }\r\n  }\r\n}\r\n\r\n// Sets the value of a `ref`.\r\n// Before React Hooks were introduced, `ref`s used to be functions.\r\n// After React Hooks were introduces, `ref`s became objects with `.current` property.\r\n// This function sets a `ref`'s value regardless of its internal implementation,\r\n// so it supports both types of `ref`s.\r\nfunction setRefValue(ref, value) {\r\n  if (typeof ref === 'function') {\r\n    ref(value)\r\n  } else {\r\n    ref.current = value\r\n  }\r\n}"],"mappings":";;;;;;;;AAAA;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,cAAT,CAAwBC,WAAxB,EAAqC;EAClD;EACA;EACA,IAAMC,OAAO,GAAG,IAAAC,aAAA,GAAhB,CAHkD,CAKlD;;EACA,IAAMC,SAAS,GAAG,IAAAC,kBAAA,EAAY,UAACC,KAAD,EAAW;IACvCC,YAAY,CAAC,CAACN,WAAD,EAAcC,OAAd,CAAD,EAAyBI,KAAzB,CAAZ;EACD,CAFiB,EAEf,CACDL,WADC,EAEDC,OAFC,CAFe,CAAlB;EAOA,OAAO,CAACA,OAAD,EAAUE,SAAV,CAAP;AACD,C,CAED;AACA;;;AACO,SAASG,YAAT,CAAsBC,IAAtB,EAA4BF,KAA5B,EAAmC;EACxC,qDAAkBE,IAAlB,wCAAwB;IAAA,IAAbC,GAAa;;IACtB,IAAIA,GAAJ,EAAS;MACPC,WAAW,CAACD,GAAD,EAAMH,KAAN,CAAX;IACD;EACF;AACF,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASI,WAAT,CAAqBD,GAArB,EAA0BH,KAA1B,EAAiC;EAC/B,IAAI,OAAOG,GAAP,KAAe,UAAnB,EAA+B;IAC7BA,GAAG,CAACH,KAAD,CAAH;EACD,CAFD,MAEO;IACLG,GAAG,CAACE,OAAJ,GAAcL,KAAd;EACD;AACF"}